package com.pcagrade.order.controller;

import java.util.stream.Collectors;
import java.util.Map;
import java.util.HashMap;
import com.pcagrade.order.PlanningApplication;
import com.pcagrade.order.service.OrderService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import lombok.extern.slf4j.Slf4j;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDateTime;
import java.util.*;

import java.time.LocalDate;
import java.util.stream.Stream;


import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import com.pcagrade.order.entity.Order;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/orders")
public class OrderController {
    @Autowired
    private OrderService orderService;

    @Autowired
    private EntityManager entityManager;

    private static final Logger log = LoggerFactory.getLogger(OrderController.class);

    /**
     * Main endpoint for orders with pagination and filters
     * Returns paginated orders with card count statistics
     */
    @GetMapping("")
    public ResponseEntity<Map<String, Object>> getOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "500") int size,
            @RequestParam(required = false) String delai,
            @RequestParam(required = false) Integer status,
            @RequestParam(required = false) String search
    ) {
        try {
            log.info("üì¶ GET /api/orders - page: {}, size: {}, delai: {}, status: {}, search: {}",
                    page, size, delai, status, search);

            // Build base query with filters
            StringBuilder sqlBuilder = new StringBuilder("""
            SELECT 
                HEX(o.id) as id, 
                o.num_commande as orderNumber, 
                o.delai, 
                o.status,
                o.date as creationDate,
                o.reference,
                o.num_commande_client as clientOrderNumber,
                COALESCE(
                    (SELECT COUNT(*) FROM card_certification_order cco WHERE cco.order_id = o.id),
                    0
                ) as cardCount,
                COALESCE(
                    (SELECT COUNT(*) FROM card_certification_order cco 
                     JOIN card_certification cc ON cco.card_certification_id = cc.id 
                     JOIN card_translation ct ON cc.card_id = ct.translatable_id
                     WHERE cco.order_id = o.id AND ct.name IS NOT NULL AND ct.name != ''),
                    0
                ) as cardsWithName,
                COALESCE(
                    (SELECT i.total_ht FROM invoice i WHERE i.order_id = o.id LIMIT 1),
                    0
                ) as totalPrice
            FROM `order` o
            WHERE o.annulee = 0
            """);

            List<Object> parameters = new ArrayList<>();

            // Apply filters
            if (delai != null && !delai.isEmpty()) {
                sqlBuilder.append(" AND o.delai = ?");
                parameters.add(delai);
            }

            if (status != null) {
                sqlBuilder.append(" AND o.status = ?");
                parameters.add(status);
            }

            if (search != null && !search.trim().isEmpty()) {
                sqlBuilder.append(" AND (o.num_commande LIKE ?");
                sqlBuilder.append(" OR o.num_commande_client LIKE ?").append(")");
                String searchPattern = "%" + search.trim() + "%";
                parameters.add(searchPattern);
                parameters.add(searchPattern);
            }

            // Order and pagination
            sqlBuilder.append("""
             ORDER BY o.date DESC
            LIMIT ? OFFSET ?
            """);

            parameters.add(size);
            parameters.add(page * size);

            // Execute main query
            Query query = entityManager.createNativeQuery(sqlBuilder.toString());
            for (int i = 0; i < parameters.size(); i++) {
                query.setParameter(i + 1, parameters.get(i));
            }

            @SuppressWarnings("unchecked")
            List<Object[]> results = query.getResultList();

            // Build orders list and calculate page card total
            List<Map<String, Object>> orders = new ArrayList<>();
            int pageCardTotal = 0;

            for (Object[] row : results) {
                Map<String, Object> order = new HashMap<>();
                order.put("id", row[0]);
                order.put("orderNumber", row[1]);
                order.put("delai", row[2]);
                order.put("status", row[3]);
                order.put("creationDate", row[4].toString().split(" ")[0]);
                order.put("reference", row[5]);
                order.put("clientOrderNumber", row[6]);

                int cardCount = ((Number) row[7]).intValue();
                int cardsWithName = ((Number) row[8]).intValue();
                double totalPrice = row[9] != null ? ((Number) row[9]).doubleValue() : 0.0;

                order.put("cardCount", cardCount);
                order.put("cardsWithName", cardsWithName);
                order.put("namePercentage", cardCount > 0 ? Math.round((cardsWithName * 100.0) / cardCount) : 0);
                order.put("totalPrice", totalPrice);
                order.put("estimatedTimeMinutes", cardCount * 3);
                order.put("languageCode", "fr");
                order.put("hasSpecialGrades", false);

                // Add to page card total
                pageCardTotal += cardCount;

                orders.add(order);
            }

            // Count query for total orders
            String countSql = buildCountQuery(delai, status, search);
            Query countQuery = entityManager.createNativeQuery(countSql);

            int countParamIndex = 1;
            if (delai != null && !delai.isEmpty()) {
                countQuery.setParameter(countParamIndex++, delai);
            }
            if (status != null) {
                countQuery.setParameter(countParamIndex++, status);
            }
            if (search != null && !search.trim().isEmpty()) {
                String searchPattern = "%" + search.trim() + "%";
                countQuery.setParameter(countParamIndex++, searchPattern);
                countQuery.setParameter(countParamIndex++, searchPattern);
            }

            Number totalCount = (Number) countQuery.getSingleResult();
            int total = totalCount.intValue();
            int totalPages = (int) Math.ceil((double) total / size);

            // Query for total cards across all filtered orders
            String cardTotalSql = buildCardTotalQuery(delai, status, search);
            Query cardTotalQuery = entityManager.createNativeQuery(cardTotalSql);

            int cardParamIndex = 1;
            if (delai != null && !delai.isEmpty()) {
                cardTotalQuery.setParameter(cardParamIndex++, delai);
            }
            if (status != null) {
                cardTotalQuery.setParameter(cardParamIndex++, status);
            }
            if (search != null && !search.trim().isEmpty()) {
                String searchPattern = "%" + search.trim() + "%";
                cardTotalQuery.setParameter(cardParamIndex++, searchPattern);
                cardTotalQuery.setParameter(cardParamIndex++, searchPattern);
            }

            Number allCardsTotal = (Number) cardTotalQuery.getSingleResult();
            int totalCards = allCardsTotal != null ? allCardsTotal.intValue() : 0;

            // Pagination metadata
            Map<String, Object> pagination = new HashMap<>();
            pagination.put("page", page);
            pagination.put("size", size);
            pagination.put("total", total);
            pagination.put("totalPages", totalPages);
            pagination.put("hasNext", page < totalPages - 1);
            pagination.put("hasPrevious", page > 0);
            pagination.put("pageCardTotal", pageCardTotal);
            pagination.put("totalCards", totalCards);

            // Quick statistics
            Map<String, Long> delaiStats = orders.stream()
                    .collect(Collectors.groupingBy(
                            o -> (String) o.get("delai"),
                            Collectors.counting()
                    ));

            // Complete response
            Map<String, Object> response = new HashMap<>();
            response.put("orders", orders);
            response.put("pagination", pagination);
            response.put("delaiDistribution", delaiStats);
            response.put("filters", Map.of(
                    "delai", delai != null ? delai : "all",
                    "status", status != null ? status : "all",
                    "search", search != null ? search : ""
            ));
// Apr√®s avoir calcul√© delaiStats, ajoutez les statistiques de statut
            Map<Integer, Long> statusStats = orders.stream()
                    .collect(Collectors.groupingBy(
                            o -> (Integer) o.get("status"),
                            Collectors.counting()
                    ));
// Calculer les groupes de statuts
            long toReceive = statusStats.getOrDefault(1, 0L);
            long packageAccepted = statusStats.getOrDefault(9, 0L);
            long inProcessing = Stream.of(10, 11, 2, 3, 4, 7, 6)
                    .mapToLong(s -> statusStats.getOrDefault(s, 0L))
                    .sum();
            long toDeliver = Stream.of(41, 42)
                    .mapToLong(s -> statusStats.getOrDefault(s, 0L))
                    .sum();
            long completed = Stream.of(5, 8)
                    .mapToLong(s -> statusStats.getOrDefault(s, 0L))
                    .sum();

// Ajouter √† la r√©ponse
            response.put("statusStats", Map.of(
                    "toReceive", toReceive,
                    "packageAccepted", packageAccepted,
                    "inProcessing", inProcessing,
                    "toDeliver", toDeliver,
                    "completed", completed
            ));




            log.info("‚úÖ Returning {} orders (page {}/{}) - Page cards: {}, Total cards: {}",
                    orders.size(), page + 1, totalPages, pageCardTotal, totalCards);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("‚ùå Error fetching orders", e);
            return ResponseEntity.status(500).body(Map.of(
                    "error", e.getMessage(),
                    "orders", new ArrayList<>(),
                    "pagination", Map.of()
            ));
        }
    }

    /**
     * Build count query with same filters as main query
     */
    private String buildCountQuery(String delai, Integer status, String search) {
        StringBuilder sql = new StringBuilder("""
            SELECT COUNT(*) FROM `order` o
            WHERE o.annulee = 0
            """);

        if (delai != null && !delai.isEmpty()) {
            sql.append(" AND o.delai = ?");
        }
        if (status != null) {
            sql.append(" AND o.status = ?");
        }
        if (search != null && !search.trim().isEmpty()) {
            sql.append(" AND (o.num_commande LIKE ? OR o.num_commande_client LIKE ?)");
        }

        return sql.toString();
    }

    /**
     * Build query to get total card count for all filtered orders
     */
    private String buildCardTotalQuery(String delai, Integer status, String search) {
        StringBuilder sql = new StringBuilder("""
            SELECT COALESCE(SUM(
                (SELECT COUNT(*) FROM card_certification_order cco WHERE cco.order_id = o.id)
            ), 0)
            FROM `order` o
            WHERE o.annulee = 0
            """);

        if (delai != null && !delai.isEmpty()) {
            sql.append(" AND o.delai = ?");
        }
        if (status != null) {
            sql.append(" AND o.status = ?");
        }
        if (search != null && !search.trim().isEmpty()) {
            sql.append(" AND (o.num_commande LIKE ? OR o.num_commande_client LIKE ?)");
        }

        return sql.toString();
    }


    @GetMapping("/frontend/orders")
    public ResponseEntity<List<Map<String, Object>>> getOrdersFrontend() {
        try {
            System.out.println("Frontend: Retrieving orders with real data");

            // Use the correct method that returns List<Map<String, Object>>
            List<Map<String, Object>> orders = orderService.getRecentOrdersAsMap();

            System.out.println("" + orders.size() + " orders returned");
            return ResponseEntity.ok(orders);

        } catch (Exception e) {
            System.err.println("Error retrieving orders: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }

    /**
     * GET /api/orders/{id}/cards - Get cards for a specific order
     * Fixed version with proper error handling and data mapping
     * Get cards for a specific order
     */
    @GetMapping("/{id}/cards")
    public ResponseEntity<Map<String, Object>> getOrderCards(@PathVariable String id) {
        try {
            log.info("üÉè GET /api/orders/{}/cards", id);

            String sql = """
                SELECT 
                    cc.id,
                    cc.grade,
                    cc.quantity,
                    ct.name as cardName
                FROM card_certification cc
                JOIN card_certification_order cco ON cc.id = cco.card_certification_id
                LEFT JOIN card_translation ct ON cc.card_id = ct.translatable_id
                WHERE cco.order_id = UNHEX(?)
                ORDER BY cc.id
                """;

            Query query = entityManager.createNativeQuery(sql);
            query.setParameter(1, id);

            @SuppressWarnings("unchecked")
            List<Object[]> results = query.getResultList();

            List<Map<String, Object>> cards = new ArrayList<>();
            int totalCards = 0;
            int cardsWithName = 0;

            for (Object[] row : results) {
                Map<String, Object> card = new HashMap<>();
                card.put("id", row[0]);
                card.put("grade", row[1]);
                card.put("quantity", row[2]);
                card.put("name", row[3]);

                if (row[3] != null && !row[3].toString().isEmpty()) {
                    cardsWithName++;
                }
                totalCards++;

                cards.add(card);
            }

            int namePercentage = Math.toIntExact(totalCards > 0 ? Math.round((cardsWithName / (double) totalCards) * 100) : 0);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("orderId", id);
            response.put("cards", cards);
            response.put("totalCards", totalCards);
            response.put("cardsWithName", cardsWithName);
            response.put("namePercentage", namePercentage);
            response.put("estimatedDuration", totalCards * 3);

            log.info("‚úÖ Found {} cards for order {}", totalCards, id);
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("‚ùå Error loading cards for order {}", id, e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("success", false);
            errorResponse.put("error", e.getMessage());
            errorResponse.put("orderId", id);
            errorResponse.put("cards", new ArrayList<>());
            errorResponse.put("totalCards", 0);

            return ResponseEntity.status(500).body(errorResponse);
        }
    }
    /**
     * Get all orders with pagination support
     */
    @GetMapping("/all")
    public ResponseEntity<List<Map<String, Object>>> getAllOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "20") int size) {
        try {
            System.out.println("Retrieving all orders - page: " + page + ", size: " + size);

            List<Map<String, Object>> orders = orderService.getAllOrdersAsMap();

            // Simple pagination
            int start = page * size;
            int end = Math.min(start + size, orders.size());

            if (start >= orders.size()) {
                return ResponseEntity.ok(new ArrayList<>());
            }

            List<Map<String, Object>> paginatedOrders = orders.subList(start, end);

            System.out.println("Returning " + paginatedOrders.size() + " orders (page " + page + ")");
            return ResponseEntity.ok(paginatedOrders);

        } catch (Exception e) {
            System.err.println("Error retrieving all orders: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }

    /**
     * Get orders for planning since a specific date
     */
    @GetMapping("/planning")
    public ResponseEntity<List<Map<String, Object>>> getOrdersForPlanning(
            @RequestParam int day,
            @RequestParam int month,
            @RequestParam int year) {
        try {
            System.out.println("Retrieving orders for planning since: " + day + "/" + month + "/" + year);

            List<Map<String, Object>> orders = orderService.getOrdersForPlanning(day, month, year);

            System.out.println("" + orders.size() + " orders found for planning");
            return ResponseEntity.ok(orders);

        } catch (Exception e) {
            System.err.println("Error retrieving orders for planning: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }

    /**
     * Get order statistics
     */
    @GetMapping("/statistics")
    public ResponseEntity<Map<String, Object>> getOrderStatistics() {
        try {
            System.out.println("Retrieving order statistics");

            Map<String, Object> statistics = orderService.getOrderStatistics();

            System.out.println("Order statistics retrieved successfully");
            return ResponseEntity.ok(statistics);

        } catch (Exception e) {
            System.err.println("Error retrieving order statistics: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(Map.of(
                    "success", false,
                    "error", e.getMessage()
            ));
        }
    }

    /**
     * Search orders by various criteria
     */
    @GetMapping("/search")
    public ResponseEntity<List<Map<String, Object>>> searchOrders(
            @RequestParam(required = false) String searchTerm,
            @RequestParam(required = false) String status,
            @RequestParam(required = false) String priority) {
        try {
            System.out.println("Searching orders with criteria: " + searchTerm + ", " + status + ", " + priority);

            // Convert string parameters to enums if provided
            Integer orderStatusCode = null;
            if (status != null && !status.isEmpty()) {
                try {
                    // Try parsing as integer directly (since statuses are stored as integers)
                    orderStatusCode = Integer.parseInt(status);
                } catch (NumberFormatException e) {
                    // If not a number, try mapping from string names to status codes
                    switch (status.toUpperCase()) {
                        case "PENDING", "TO_RECEIVE" -> orderStatusCode = Order.STATUS_A_RECEPTIONNER;
                        case "PACKAGE_ACCEPTED" -> orderStatusCode = Order.STATUS_COLIS_ACCEPTE;
                        case "TO_SCAN" -> orderStatusCode = Order.STATUS_A_SCANNER;
                        case "TO_OPEN" -> orderStatusCode = Order.STATUS_A_OUVRIR;
                        case "TO_EVALUATE" -> orderStatusCode = Order.STATUS_A_NOTER;
                        case "TO_CERTIFY" -> orderStatusCode = Order.STATUS_A_CERTIFIER;
                        case "TO_PREPARE" -> orderStatusCode = Order.STATUS_A_PREPARER;
                        case "TO_UNSEAL" -> orderStatusCode = Order.STATUS_A_DESCELLER;
                        case "TO_SEE" -> orderStatusCode = Order.STATUS_A_VOIR;
                        case "TO_DISTRIBUTE" -> orderStatusCode = Order.STATUS_A_DISTRIBUER;
                        case "TO_SEND" -> orderStatusCode = Order.STATUS_A_ENVOYER;
                        case "SENT" -> orderStatusCode = Order.STATUS_ENVOYEE;
                        case "RECEIVED" -> orderStatusCode = Order.STATUS_RECU;
                        default -> {
                            System.err.println("Unknown status string: " + status);
                            orderStatusCode = null;
                        }
                    }
                }
            }

            String delai = null;
            if (priority != null && !priority.isEmpty()) {
                // Map old priority names to delai codes
                delai = switch (priority.toUpperCase()) {
                    case "EXCELSIOR" -> "X";
                    case "FAST_PLUS" -> "F+";
                    case "FAST" -> "F";
                    case "CLASSIC" -> "C";
                    case "ECONOMY" -> "E";
                    default -> priority; // If already in delai format (X, F+, F, C, E)
                };
            }

// Update the service call to use Integer instead of OrderStatus
            List<Order> orders = orderService.searchOrders(searchTerm, statusInt, delai);

            List<Map<String, Object>> orderMaps = orders.stream()
                    .map(order -> {
                        Map<String, Object> orderMap = Map.of(
                                "id", order.getId().toString(),
                                "orderNumber", order.getOrderNumber(),
                                "customerName", order.getCustomerName(),
                                "orderDate", order.getOrderDate(),
                                "status", order.getStatusText(),
                                "priority", order.getPriority().name(),
                                "cardCount", order.getCardCount(),
                                "totalPrice", order.getTotalPrice()
                        );
                        return orderMap;
                    })
                    .toList();

            System.out.println("" + orderMaps.size() + " orders found matching criteria");
            return ResponseEntity.ok(orderMaps);

        } catch (Exception e) {
            System.err.println("Error searching orders: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(500).body(new ArrayList<>());
        }
    }

    // ========== Alternative endpoint pour debug ==========

    private String mapStatusToText(Number statusNumber) {
        if (statusNumber == null) return "Unknown";

        int status = statusNumber.intValue();
        return switch (status) {
            case Order.STATUS_A_RECEPTIONNER -> "A_RECEPTIONNER";
            case Order.STATUS_COLIS_ACCEPTE -> "COLIS_ACCEPTE";
            case Order.STATUS_A_SCANNER -> "A_SCANNER";
            case Order.STATUS_A_OUVRIR -> "A_OUVRIR";
            case Order.STATUS_A_NOTER -> "A_NOTER";
            case Order.STATUS_A_CERTIFIER -> "A_CERTIFIER";
            case Order.STATUS_A_PREPARER -> "A_PREPARER";
            case Order.STATUS_A_DESCELLER -> "A_DESCELLER";
            case Order.STATUS_A_VOIR -> "A_VOIR";
            case Order.STATUS_A_DISTRIBUER -> "A_DISTRIBUER";
            case Order.STATUS_A_ENVOYER -> "A_ENVOYER";
            case Order.STATUS_ENVOYEE -> "ENVOYEE";
            case Order.STATUS_RECU -> "RECU";
            default -> "UNKNOWN";
        };

    }

}