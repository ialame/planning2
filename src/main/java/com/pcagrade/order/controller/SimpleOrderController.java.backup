package com.pcagrade.order.controller;

import jakarta.persistence.EntityManager;
import jakarta.persistence.Query;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.*;

/**
 * Simple Order Controller
 * Uses direct SQL queries via EntityManager to avoid entity dependencies
 * Provides API endpoints for frontend Orders page
 */
@RestController
@RequestMapping("/api/orders")
public class SimpleOrderController {

    private static final Logger log = LoggerFactory.getLogger(SimpleOrderController.class);

    @Autowired
    private EntityManager entityManager;

    /**
     * GET /api/orders
     * Main endpoint for orders list with pagination and filters
     */
    @GetMapping("")
    public ResponseEntity<Map<String, Object>> getOrders(
            @RequestParam(defaultValue = "0") int page,
            @RequestParam(defaultValue = "500") int size,
            @RequestParam(required = false) String delai,
            @RequestParam(required = false) Integer status,
            @RequestParam(required = false) String search
    ) {
        try {
            log.info("üì¶ GET /api/orders - page: {}, size: {}, delai: {}, status: {}, search: {}",
                    page, size, delai, status, search);

            // Build base query
            StringBuilder sqlBuilder = new StringBuilder("""
                SELECT 
                    HEX(o.id) as id, 
                    o.num_commande as orderNumber, 
                    o.delai, 
                    o.status,
                    o.date as creationDate,
                    o.reference,
                    o.num_commande_client as clientOrderNumber,
                    COALESCE(
                        (SELECT COUNT(*) FROM card_certification_order cco WHERE cco.order_id = o.id),
                        0
                    ) as cardCount,
                    COALESCE(
                        (SELECT COUNT(*) FROM card_certification_order cco 
                         JOIN card_certification cc ON cco.card_certification_id = cc.id 
                         JOIN card_translation ct ON cc.card_id = ct.translatable_id
                         WHERE cco.order_id = o.id AND ct.name IS NOT NULL AND ct.name != ''),
                        0
                    ) as cardsWithName,
                    COALESCE(
                        (SELECT i.total_ht FROM invoice i WHERE i.order_id = o.id LIMIT 1),
                        0
                    ) as totalPrice
                FROM `order` o
                WHERE o.annulee = 0
                """);

            List<Object> parameters = new ArrayList<>();
            int paramIndex = 1;

            // Apply filters
            if (delai != null && !delai.isEmpty() && !"all".equals(delai)) {
                sqlBuilder.append(" AND o.delai = ?").append(paramIndex++);
                parameters.add(delai);
            }

            if (status != null) {
                sqlBuilder.append(" AND o.status = ?").append(paramIndex++);
                parameters.add(status);
            }

            if (search != null && !search.trim().isEmpty()) {
                sqlBuilder.append(" AND (o.num_commande LIKE ?").append(paramIndex)
                        .append(" OR o.num_commande_client LIKE ?").append(paramIndex + 1).append(")");
                String likePattern = "%" + search.trim() + "%";
                parameters.add(likePattern);
                parameters.add(likePattern);
                paramIndex += 2;
            }

            // Order by priority and date
            sqlBuilder.append(" ORDER BY CASE o.delai WHEN 'X' THEN 1 WHEN 'F+' THEN 2 WHEN 'F' THEN 3 WHEN 'C' THEN 4 ELSE 5 END, o.date DESC");

            // Count total (for pagination)
            String countSql = "SELECT COUNT(*) FROM `order` o WHERE o.annulee = 0";
            if (delai != null && !delai.isEmpty() && !"all".equals(delai)) {
                countSql += " AND o.delai = ?";
            }
            if (status != null) {
                countSql += " AND o.status = ?";
            }
            if (search != null && !search.trim().isEmpty()) {
                countSql += " AND (o.num_commande LIKE ? OR o.num_commande_client LIKE ?)";
            }

            Query countQuery = entityManager.createNativeQuery(countSql);
            int countParamIndex = 1;
            if (delai != null && !delai.isEmpty() && !"all".equals(delai)) {
                countQuery.setParameter(countParamIndex++, delai);
            }
            if (status != null) {
                countQuery.setParameter(countParamIndex++, status);
            }
            if (search != null && !search.trim().isEmpty()) {
                String likePattern = "%" + search.trim() + "%";
                countQuery.setParameter(countParamIndex++, likePattern);
                countQuery.setParameter(countParamIndex++, likePattern);
            }

            Number totalCount = (Number) countQuery.getSingleResult();
            long total = totalCount.longValue();
            int totalPages = (int) Math.ceil((double) total / size);

            // Add pagination to main query
            sqlBuilder.append(" LIMIT ").append(size).append(" OFFSET ").append(page * size);

            // Execute main query
            Query query = entityManager.createNativeQuery(sqlBuilder.toString());
            for (int i = 0; i < parameters.size(); i++) {
                query.setParameter(i + 1, parameters.get(i));
            }

            @SuppressWarnings("unchecked")
            List<Object[]> results = query.getResultList();

            // Convert results to list of maps
            List<Map<String, Object>> orders = new ArrayList<>();
            int pageCardTotal = 0;

            for (Object[] row : results) {
                Map<String, Object> order = new HashMap<>();

                order.put("id", row[0]);
                order.put("orderNumber", row[1]);
                order.put("delai", row[2]);
                order.put("status", row[3]);
                order.put("creationDate", row[4] != null ? row[4].toString() : "");
                order.put("reference", row[5]);
                order.put("clientOrderNumber", row[6]);

                int cardCount = row[7] != null ? ((Number) row[7]).intValue() : 0;
                int cardsWithName = row[8] != null ? ((Number) row[8]).intValue() : 0;
                float totalPrice = row[9] != null ? ((Number) row[9]).floatValue() : 0.0f;

                order.put("cardCount", cardCount);
                order.put("cardsWithName", cardsWithName);
                order.put("namePercentage", cardCount > 0 ? Math.round((cardsWithName / (float) cardCount) * 100) : 0);
                order.put("totalPrice", totalPrice);

                pageCardTotal += cardCount;
                orders.add(order);
            }

            // Calculate total cards across ALL orders (not just current page)
            String totalCardsSql = """
                SELECT COALESCE(SUM(
                    (SELECT COUNT(*) FROM card_certification_order cco WHERE cco.order_id = o.id)
                ), 0)
                FROM `order` o WHERE o.annulee = 0
                """;
            Query totalCardsQuery = entityManager.createNativeQuery(totalCardsSql);
            Number allCardsTotal = (Number) totalCardsQuery.getSingleResult();
            int totalCards = allCardsTotal != null ? allCardsTotal.intValue() : 0;

            // Pagination metadata
            Map<String, Object> pagination = new HashMap<>();
            pagination.put("page", page);
            pagination.put("size", size);
            pagination.put("total", total);
            pagination.put("totalPages", totalPages);
            pagination.put("hasNext", page < totalPages - 1);
            pagination.put("hasPrevious", page > 0);
            pagination.put("pageCardTotal", pageCardTotal);
            pagination.put("totalCards", totalCards);

            // Quick statistics
            Map<String, Long> delaiStats = new HashMap<>();
            String statsSql = "SELECT o.delai, COUNT(*) FROM `order` o WHERE o.annulee = 0 GROUP BY o.delai";
            @SuppressWarnings("unchecked")
            List<Object[]> statsResults = entityManager.createNativeQuery(statsSql).getResultList();
            for (Object[] stat : statsResults) {
                String delaiKey = stat[0] != null ? stat[0].toString() : "unknown";
                Long count = ((Number) stat[1]).longValue();
                delaiStats.put(delaiKey, count);
            }

            // Complete response
            Map<String, Object> response = new HashMap<>();
            response.put("orders", orders);
            response.put("pagination", pagination);
            response.put("delaiDistribution", delaiStats);
            response.put("filters", Map.of(
                    "delai", delai != null ? delai : "all",
                    "status", status != null ? status : "all",
                    "search", search != null ? search : ""
            ));

            log.info("‚úÖ Returned {} orders (page {}/{})", orders.size(), page + 1, totalPages);
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("‚ùå Error loading orders", e);
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("success", false);
            errorResponse.put("error", e.getMessage());
            errorResponse.put("orders", new ArrayList<>());
            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    /**
     * GET /api/orders/{id}
     * Get single order details
     */
    @GetMapping("/{id}")
    public ResponseEntity<Map<String, Object>> getOrder(@PathVariable String id) {
        try {
            log.info("üìã GET /api/orders/{}", id);

            String sql = """
                SELECT 
                    HEX(o.id) as id,
                    o.num_commande as orderNumber,
                    o.delai,
                    o.status,
                    o.date as creationDate,
                    o.reference,
                    o.num_commande_client as clientOrderNumber
                FROM `order` o
                WHERE HEX(o.id) = ? AND o.annulee = 0
                """;

            Query query = entityManager.createNativeQuery(sql);
            query.setParameter(1, id.toUpperCase().replace("-", ""));

            @SuppressWarnings("unchecked")
            List<Object[]> results = query.getResultList();

            if (results.isEmpty()) {
                Map<String, Object> errorResponse = new HashMap<>();
                errorResponse.put("success", false);
                errorResponse.put("error", "Order not found");
                return ResponseEntity.status(404).body(errorResponse);
            }

            Object[] row = results.get(0);
            Map<String, Object> order = new HashMap<>();
            order.put("id", row[0]);
            order.put("orderNumber", row[1]);
            order.put("delai", row[2]);
            order.put("status", row[3]);
            order.put("creationDate", row[4] != null ? row[4].toString() : "");
            order.put("reference", row[5]);
            order.put("clientOrderNumber", row[6]);

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("order", order);

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("‚ùå Error loading order {}", id, e);
            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("success", false);
            errorResponse.put("error", e.getMessage());
            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    /**
     * GET /api/orders/{id}/cards
     * Get cards for a specific order
     */
    @GetMapping("/{id}/cards")
    public ResponseEntity<Map<String, Object>> getOrderCards(@PathVariable String id) {
        try {
            log.info("üé¥ GET /api/orders/{}/cards", id);

            String sql = """
                SELECT 
                    HEX(cc.id) as id,
                    cc.grade,
                    cco.amount as quantity,
                    ct.name
                FROM card_certification_order cco
                JOIN card_certification cc ON cco.card_certification_id = cc.id
                LEFT JOIN card_translation ct ON cc.card_id = ct.translatable_id
                WHERE HEX(cco.order_id) = ?
                ORDER BY cc.id
                """;

            Query query = entityManager.createNativeQuery(sql);
            query.setParameter(1, id.toUpperCase().replace("-", ""));

            @SuppressWarnings("unchecked")
            List<Object[]> results = query.getResultList();

            List<Map<String, Object>> cards = new ArrayList<>();
            int totalCards = 0;
            int cardsWithName = 0;

            for (Object[] row : results) {
                Map<String, Object> card = new HashMap<>();
                card.put("id", row[0]);
                card.put("grade", row[1]);
                card.put("quantity", row[2]);
                card.put("name", row[3]);

                if (row[3] != null && !row[3].toString().isEmpty()) {
                    cardsWithName++;
                }
                totalCards++;

                cards.add(card);
            }

            int namePercentage = totalCards > 0 ? Math.round((cardsWithName / (float) totalCards) * 100) : 0;

            Map<String, Object> response = new HashMap<>();
            response.put("success", true);
            response.put("orderId", id);
            response.put("cards", cards);
            response.put("totalCards", totalCards);
            response.put("cardsWithName", cardsWithName);
            response.put("namePercentage", namePercentage);
            response.put("estimatedDuration", totalCards * 3);

            log.info("‚úÖ Found {} cards for order {}", totalCards, id);
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            log.error("‚ùå Error loading cards for order {}", id, e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("success", false);
            errorResponse.put("error", e.getMessage());
            errorResponse.put("orderId", id);
            errorResponse.put("cards", new ArrayList<>());
            errorResponse.put("totalCards", 0);

            return ResponseEntity.status(500).body(errorResponse);
        }
    }
}